<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãšã‚“ã ã‚‚ã‚“åœ°éœ‡ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root { color-scheme: light dark; }
  body { margin:0; font-family:'Noto Sans JP',system-ui,sans-serif; background:#f5f7fa; display:flex; flex-direction:column; min-height:100vh; }
  header { padding:12px 18px; background:#ffffffd9; backdrop-filter:blur(4px); border-bottom:1px solid #ddd; }
  header h1 { margin:0; font-size:20px; display:flex; gap:8px; align-items:center; }
  main { flex:1; display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
  .sidebar { display:flex; flex-direction:column; gap:12px; }
  .card { background:#fff; border:1px solid #dcdcdc; border-radius:12px; padding:12px; box-shadow:0 1px 2px rgba(0,0,0,.06); }
  .card h2 { margin:0 0 8px; font-size:16px; }
  .chat-wrap { display:flex; flex-direction:column; height:100%; }
  .messages { flex:1; overflow:auto; padding:12px; background:#fff; border:1px solid #dcdcdc; border-radius:12px; display:flex; flex-direction:column; gap:12px; }
  .msg { max-width:720px; padding:10px 14px; border-radius:14px; line-height:1.5; font-size:14px; position:relative; display:flex; gap:10px; }
  .msg.user { margin-left:auto; background:#2b7bff; color:#fff; }
  .msg.bot { background:#e9eef5; }
  .msg.bot:before { content:'ãšã‚“ã ã‚‚ã‚“'; font-size:11px; position:absolute; top:-14px; left:46px; color:#6a7b8d; }
  .msg .avatar { flex:0 0 auto; width:28px; height:28px; border-radius:50%; overflow:hidden; border:1px solid rgba(0,0,0,.1); background:#fff; display:none; align-self:flex-start; }
  .msg .avatar img { width:100%; height:100%; object-fit:cover; object-position:50% 30%; display:block; }
  .msg.bot .avatar { display:block; }
  /* replay button */
  .msg .play { position:absolute; top:6px; right:8px; border:none; background:transparent; cursor:pointer; color:#333; font-size:16px; padding:2px; opacity:.8; }
  .msg .play:hover { opacity:1; transform:scale(1.05); }
  .msg.user .play { display:none; }
  form { display:flex; gap:8px; margin-top:12px; }
  input[type=text] { flex:1; padding:10px 12px; border:1px solid #bbb; border-radius:10px; font-size:14px; }
  button { padding:10px 14px; border-radius:10px; border:1px solid #2b7bff; background:#2b7bff; color:#fff; cursor:pointer; font-size:14px; }
  button.secondary { background:#fff; color:#2b7bff; }
  button:disabled { opacity:.55; cursor:not-allowed; }
  .event-tip { font-size:12px; color:#555; }
  .mic-btn { width:42px; height:42px; border-radius:50%; border:1px solid #999; background:#fff; display:flex; justify-content:center; align-items:center; cursor:pointer; }
  .mic-btn.recording { background:#ff4d4f; color:#fff; border-color:#ff4d4f; animation:pulse 1.2s infinite; }
  @keyframes pulse { 0%{ box-shadow:0 0 0 0 rgba(255,77,79,.5);} 70%{ box-shadow:0 0 0 12px rgba(255,77,79,0);} 100%{ box-shadow:0 0 0 0 rgba(255,77,79,0);} }
  .footer-note { font-size:11px; color:#777; margin-top:6px; }
  .loading { font-size:12px; color:#666; }
  .voice-toggle { display:flex; align-items:center; gap:6px; font-size:12px; }
  .tts-status { font-size:11px; color:#555; margin-top:4px; padding:4px 8px; background:#fff; border:1px solid #e0e0e0; border-radius:6px; }
  .tts-status.error { color:#c62828; border-color:#f4b4b4; background:#ffecec; }

  /* Minimal mode: only chat (messages + input) */
  body.minimal header { display:none; }
  body.minimal .sidebar { display:none; }
  body.minimal .footer-note { display:none; }
  body.minimal main { grid-template-columns: 1fr; padding: 10px; }
  body.minimal .messages { min-height: 200px; }
</style>
</head>
<body>
<header>
  <h1>ğŸŒ± ãšã‚“ã ã‚‚ã‚“åœ°éœ‡ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ</h1>
  <div style="font-size:12px;color:#666;">åœ°éœ‡ã‚¤ãƒ™ãƒ³ãƒˆã®æ—¥ä»˜ãƒ»å ´æ‰€ãƒ»è¦æ¨¡ã‚’è³ªå•ã—ã¦ãã ã•ã„ (ä¾‹: "2025å¹´11æœˆ10æ—¥ã®M5.2ã®åœ°éœ‡ã£ã¦ã©ã“ï¼Ÿ")</div>
</header>
<main>
  <div class="sidebar">
    <div class="card">
      <h2>ä½¿ã„æ–¹</h2>
      <ol style="margin:0;padding-left:20px;font-size:13px;line-height:1.5;">
        <li>ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã¾ãŸã¯ğŸ¤ãƒœã‚¿ãƒ³ã§éŸ³å£°è³ªå•</li>
        <li>æ—¥ä»˜(YYYY-MM-DD), ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰(Mx.x), å ´æ‰€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚ã‚‹ã¨ç²¾åº¦UP</li>
        <li>è©²å½“ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Œã°è©³ç´°ã‚’ãšã‚“ã ã‚‚ã‚“ãŒèª¬æ˜</li>
      </ol>
      <p class="event-tip">ä¾‹: <code>2025-11-10 M5.2 å²©æ‰‹æ²–ã®åœ°éœ‡ã¯ï¼Ÿ</code></p>
      <div class="voice-toggle">
        <input type="checkbox" id="voiceEnable" checked /> <label for="voiceEnable">éŸ³å£°èª­ã¿ä¸Šã’ON</label>
      </div>
    </div>
    <div class="card">
      <h2>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h2>
      <div id="status" class="loading">ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿èª­è¾¼ä¸­...</div>
    </div>
    <div class="card">
      <h2>ãƒ’ãƒ³ãƒˆ</h2>
      <ul style="margin:0;padding-left:20px;font-size:12px;line-height:1.4;">
        <li>"æœ€æ–°ã®M5ä»¥ä¸Šæ•™ãˆã¦"</li>
        <li>"2025-11-11ã®æµ…ã„åœ°éœ‡ã¯ï¼Ÿ"</li>
        <li>"M4.9ã£ã¦ã©ã®ãã‚‰ã„ã®å¼·ã•ï¼Ÿ"</li>
      </ul>
    </div>
  </div>
  <div class="chat-wrap">
  <div id="messages" class="messages"></div>
  <div id="ttsStatus" class="tts-status" style="display:none"></div>
    <form id="chatForm">
      <input id="userInput" type="text" placeholder="è³ªå•ã‚’å…¥åŠ›ã¾ãŸã¯ãƒã‚¤ã‚¯ã§è©±ã™..." autocomplete="off" />
      <button type="submit">é€ä¿¡</button>
      <div id="micBtn" class="mic-btn" title="éŸ³å£°å…¥åŠ›">ğŸ¤</div>
    </form>
    <div class="footer-note">â€» ãƒ–ãƒ©ã‚¦ã‚¶ã®Web Speech APIã¨ speechSynthesis ã‚’åˆ©ç”¨ã€‚ãšã‚“ã ã‚‚ã‚“éŸ³å£°ã¯å…¬å¼ VOICEVOX API ã‚’å‘¼ã³å‡ºã™çµ±åˆã‚³ãƒ¼ãƒ‰ä¾‹ã‚’ä¸‹ã§å‚ç…§ã§ãã¾ã™ã€‚</div>
  </div>
</main>
<script>
const messagesEl = document.getElementById('messages');
const form = document.getElementById('chatForm');
const inputEl = document.getElementById('userInput');
const micBtn = document.getElementById('micBtn');
const statusEl = document.getElementById('status');
const voiceEnableEl = document.getElementById('voiceEnable');
const defaultGreeting = 'ã“ã‚“ã«ã¡ã¯â™ªä»Šæ—¥ã¯ã©ã‚“ãªã“ã¨ã—ã¾ã™ã‹ã€‚';

// TTS configuration (browser speechSynthesis by default; optional VOICEVOX)
const ttsConfig = {
  mode: 'webspeech', // 'webspeech' | 'voicevox'
  voicevox: {
    endpoint: 'http://localhost:50021', // Change via ?vv_url=...
    speaker: 3, // ãšã‚“ã ã‚‚ã‚“ (ç’°å¢ƒã«ã‚ˆã‚ŠIDã¯ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™)
  }
};

let events = [];
let recognizing = false;
let recognition = null;
let lastEvent = null; // store last matched event for map focus

function addMessage(text, role){
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  // avatar for bot
  if (role === 'bot') {
    const av = document.createElement('div');
    av.className = 'avatar';
    const img = document.createElement('img');
    img.src = 'zunda.png';
    img.alt = 'ãšã‚“ã ã‚‚ã‚“';
    av.appendChild(img);
    div.appendChild(av);
  }
  const body = document.createElement('div');
  body.style.flex = '1 1 auto';
  body.innerHTML = text.replace(/\n/g,'<br>');
  div.appendChild(body);
  // replay button for bot messages
  if (role === 'bot') {
    const btn = document.createElement('button');
    btn.className = 'play';
    btn.type = 'button';
    btn.title = 'ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†ç”Ÿ';
    btn.setAttribute('aria-label', 'ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†ç”Ÿ');
    btn.textContent = 'ğŸ”Š';
    btn.addEventListener('click', () => speak(text, true));
    div.appendChild(btn);
  }
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

async function loadEvents(){
  try {
    const res = await fetch('earthquakes_events.json');
    events = await res.json();
    statusEl.textContent = `ã‚¤ãƒ™ãƒ³ãƒˆèª­è¾¼å®Œäº†: ${events.length}ä»¶`;
  } catch(e){
    statusEl.textContent = 'ã‚¤ãƒ™ãƒ³ãƒˆèª­è¾¼å¤±æ•—';
  }
}
loadEvents();

// Minimal mode (hide header/sidebar when ?minimal=1)
try {
  const usp = new URLSearchParams(location.search);
  if (usp.get('minimal') === '1' || usp.get('m') === '1') {
    document.body.classList.add('minimal');
  }
  // VOICEVOX params: ?vv=1&vv_url=http://localhost:50021&vv_speaker=3
  const vv = usp.get('vv');
  if (vv === '1' || vv === 'true') ttsConfig.mode = 'voicevox';
  const vvUrl = usp.get('vv_url');
  if (vvUrl) ttsConfig.voicevox.endpoint = vvUrl;
  const vvSp = usp.get('vv_speaker');
  if (vvSp) ttsConfig.voicevox.speaker = parseInt(vvSp, 10) || ttsConfig.voicevox.speaker;
  const vvDebug = usp.get('vv_debug');
  if (vvDebug === '1' || vvDebug === 'true') ttsConfig.debug = true;
} catch(e) {}

function parseQuery(q){
  const obj = { date:null, mag:null, placeTokens:[], shallow:null };
  const dateMatch = q.match(/(20\d{2}-\d{2}-\d{2})/);
  if(dateMatch) obj.date = dateMatch[1];
  const magMatch = q.match(/M\s*(\d+(?:\.\d)?)/i);
  if(magMatch) obj.mag = parseFloat(magMatch[1]);
  if(/æµ…ã„|æµ…ç™º/.test(q)) obj.shallow = true;
  const tokens = q.replace(/M\s*\d+(?:\.\d)?/i,'').split(/\s+/).filter(t=>t.length>0);
  obj.placeTokens = tokens.filter(t => /[ä¸€-é¾¥ã-ã‚“ã‚¡-ãƒ³A-Za-z]/.test(t));
  return obj;
}

function findEvent(parsed){
  let candidates = events.slice();
  if(parsed.date){
    candidates = candidates.filter(e => e.time.startsWith(parsed.date));
  }
  if(parsed.mag){
    candidates = candidates.filter(e => Math.abs(e.mag - parsed.mag) < 0.05);
  }
  if(parsed.shallow){
    candidates = candidates.filter(e => e.depthCategory === 'shallow');
  }
  if(parsed.placeTokens.length){
    const toks = parsed.placeTokens.map(t=>t.toLowerCase());
    candidates = candidates.filter(e => {
      const p = (e.place||'').toLowerCase();
      return toks.every(t => p.includes(t));
    });
  }
  // Prefer highest magnitude if multiple
  candidates.sort((a,b)=>b.mag - a.mag);
  return candidates[0] || null;
}

function formatEvent(ev){
  if(!ev) return 'è©²å½“ã™ã‚‹åœ°éœ‡ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ—¥ä»˜ (YYYY-MM-DD) ã‚„ Må€¤ã€å ´æ‰€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚ã¦å†è³ªå•ã—ã¦ãã ã•ã„ã€‚';
  return `\nã€ã‚¤ãƒ™ãƒ³ãƒˆæ¦‚è¦ã€‘\nç™ºç”Ÿæ™‚åˆ»(UTC): ${ev.time}\nãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰: M${ev.mag.toFixed(1)}\næ·±ã•: ${Math.round(ev.depth)} km (${depthLabel(ev.depthCategory)})\nå ´æ‰€: ${ev.place}\n\nã€è§£èª¬ã€‘\nã“ã®åœ°éœ‡ã¯ ${ev.place} ä»˜è¿‘ã§ç™ºç”Ÿã—ãŸ M${ev.mag.toFixed(1)} ã®åœ°éœ‡ã§ã™ã€‚æ·±ã•ã¯ç´„ ${Math.round(ev.depth)} km ã§ã€åˆ†é¡ã¯ã€Œ${depthLabel(ev.depthCategory)}ã€ã§ã™ã€‚ä¸€èˆ¬çš„ã« M${ev.mag.toFixed(1)} ã¯åœ°åŸŸã«ã‚ˆã£ã¦ä½“æ„Ÿã•ã‚Œã‚‹æºã‚ŒãŒã‚ã‚Šã€é˜²ç½æ„è­˜ã®å†ç¢ºèªã«å½¹ç«‹ã¡ã¾ã™ã€‚`; 
}

function depthLabel(cat){
  switch(cat){
    case 'shallow': return 'æµ…ç™º (0-70km)';
    case 'intermediate': return 'ä¸­æ·±ç™º (70-300km)';
    case 'deep': return 'æ·±ç™º (300km~)';
    default: return cat;
  }
}

function answer(query){
  const parsed = parseQuery(query);
  const ev = findEvent(parsed);
  lastEvent = ev;
  if (ev) {
    // postMessage to parent if embedded in iframe inside interactive map
    try { window.parent.postMessage({ type: 'chatbot-event', event: ev }, window.location.origin); } catch(e) {}
  }
  return formatEvent(ev);
}

form.addEventListener('submit', e => {
  e.preventDefault();
  const q = inputEl.value.trim();
  if(!q) return;
  addMessage(q, 'user');
  inputEl.value='';
  const ans = answer(q);
  addMessage(ans, 'bot');
  speak(ans);
});

function initRecognition(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SpeechRecognition){
    micBtn.style.display='none';
    return;
  }
  recognition = new SpeechRecognition();
  recognition.lang = 'ja-JP';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.addEventListener('result', e => {
    const text = Array.from(e.results).map(r=>r[0].transcript).join('');
    inputEl.value = text;
    addMessage(text, 'user');
    const ans = answer(text);
    addMessage(ans, 'bot');
    speak(ans);
  });
  recognition.addEventListener('end', () => {
    recognizing = false; micBtn.classList.remove('recording');
  });
}
initRecognition();

// Autofocus input when loaded
try { window.addEventListener('load', () => { setTimeout(() => { try { inputEl.focus(); } catch(e) {} }, 50); }); } catch(e) {}

micBtn.addEventListener('click', () => {
  if(!recognition) return;
  if(!recognizing){
    recognizing = true; micBtn.classList.add('recording'); recognition.start();
  } else {
    recognizing = false; micBtn.classList.remove('recording'); recognition.stop();
  }
});

async function speak(text, force=false){
  if(!force && !voiceEnableEl.checked) return;
  const clean = (text||'').replace(/ã€.*?ã€‘/g,'');
  if (ttsConfig.mode === 'voicevox') {
    try {
      await voicevoxSpeak(clean);
      updateTTSStatus('VOICEVOXå†ç”ŸæˆåŠŸ', false);
      return;
    } catch(err){
      // fallback to webspeech
      updateTTSStatus('VOICEVOXå†ç”Ÿå¤±æ•—: '+ err.message +' â†’ ãƒ–ãƒ©ã‚¦ã‚¶éŸ³å£°ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯', true);
      if (ttsConfig.debug) console.warn('VOICEVOX å†ç”Ÿã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ–ãƒ©ã‚¦ã‚¶éŸ³å£°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™:', err);
    }
  }
  // Browser speech synthesis fallback
  if(!('speechSynthesis' in window)) return;
  const utter = new SpeechSynthesisUtterance(clean);
  utter.lang = 'ja-JP';
  utter.rate = 1.0;
  const voices = speechSynthesis.getVoices();
  const jp = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('ja'));
  if(jp) utter.voice = jp;
  speechSynthesis.speak(utter);
}

async function voicevoxSpeak(text){
  const ep = ttsConfig.voicevox.endpoint.replace(/\/$/, '');
  const sp = ttsConfig.voicevox.speaker;
  // 1) audio_query
  const qRes = await fetch(`${ep}/audio_query?text=${encodeURIComponent(text)}&speaker=${encodeURIComponent(sp)}`, {
    method: 'POST',
    headers: { 'Accept': 'application/json' }
  });
  if (!qRes.ok) throw new Error(`audio_query failed: ${qRes.status}`);
  const query = await qRes.json();
  // 2) synthesis
  const sRes = await fetch(`${ep}/synthesis?speaker=${encodeURIComponent(sp)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(query)
  });
  if (!sRes.ok) throw new Error(`synthesis failed: ${sRes.status}`);
  const wav = await sRes.arrayBuffer();
  const blob = new Blob([wav], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  const audio = new Audio(url);
  await audio.play();
  // cleanup later
  setTimeout(() => URL.revokeObjectURL(url), 30_000);
}

function updateTTSStatus(msg, isError){
  const box = document.getElementById('ttsStatus');
  if (!box) return;
  box.style.display = 'block';
  box.textContent = msg;
  box.classList.toggle('error', !!isError);
}

// Re-load voices on some browsers
if ('speechSynthesis' in window) {
  speechSynthesis.onvoiceschanged = () => {};
}

// Receive open signal from parent (map) to greet on each open
window.addEventListener('message', (e) => {
  try {
    if (e.origin !== location.origin) return;
    const d = e.data || {};
    if (d.type === 'chatbot-open') {
      addMessage(defaultGreeting, 'bot');
      // small delay to allow voices populate reliably
      setTimeout(() => speak(defaultGreeting), 50);
      try { inputEl.focus(); } catch(_) {}
    }
  } catch(_) {}
});
</script>
</body>
</html>
