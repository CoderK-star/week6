<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>日本の地震マップ</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/MarkerCluster.Default.css"/>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Opening Splash -->
  <div id="siteSplash" class="splash" role="status" aria-live="polite" aria-label="読み込み中">
    <div class="splash__decor" aria-hidden="true"></div>
    <div class="splash__ring" aria-hidden="true"></div>
    <div class="splash__logo">
      <div class="splash__mark" aria-hidden="true">
        <div class="splash__mark-inner">
          <!-- Simple seismograph mark -->
          <svg class="splash__logo-svg" viewBox="0 0 64 64" aria-hidden="true">
            <path d="M6 38h6l4-8 5 12 6-20 6 26 5-12 4 8h16"/>
          </svg>
        </div>
      </div>
      <div class="splash__title"><span>地震マップ</span></div>
      <div class="splash__hint">データを読み込んでいます…</div>
    </div>
  </div>
  <div class="layout">
    <header>
      <div class="row" style="justify-content:space-between; align-items:center; gap:8px;">
        <h2 style="margin:0; font-size:18px;">地震マップ（世界/日本）</h2>
      </div>
      <div class="small" id="sourceInfo">データ: USGS（過去30日・世界）</div>
    </header>
    <aside class="panel">
      <div class="panel-tools">
        <button id="togglePanelInside" class="icon-btn" title="パネルの表示/非表示" aria-label="パネル縮小">
          <svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
          </svg>
        </button>
      </div>
      <div class="box controls">
  <h3>検索</h3>
  <input id="q" type="search" placeholder="場所キーワード (例: 北海道, 茨城, 東北)" style="width:100%; padding:8px; border-radius:8px; border:1px solid #bbb;">
        <div class="row" style="margin-top:8px;">
          <label style="flex:0 0 92px;">データソース</label>
          <select id="dataSource">
            <option value="usgs_month" selected>USGS: 過去30日 (世界)</option>
            <option value="usgs_week">USGS: 過去7日 (世界)</option>
            <option value="usgs_day">USGS: 過去24時間 (世界)</option>
            <option value="usgs_hour">USGS: 過去1時間 (世界)</option>
            <option value="local">ローカル: 日本 (過去3年)</option>
          </select>
        </div>
        <div class="row" style="margin-top:8px; align-items:center;">
          <label style="flex:0 0 92px;">リアルタイム</label>
          <label class="row" style="gap:6px; flex: 0 0 auto;">
            <input type="checkbox" id="rtEnable"> 自動更新
          </label>
          <select id="rtEvery" style="flex:0 0 110px;">
            <option value="15000">15秒</option>
            <option value="30000">30秒</option>
            <option value="60000" selected>60秒</option>
            <option value="120000">120秒</option>
          </select>
        </div>
        <div class="small muted" id="rtStatus" style="margin-top:4px;"></div>
        <div class="row" style="margin-top:8px; align-items:center;">
          <label style="flex:0 0 92px;">アラート</label>
          <label class="row" style="gap:6px; flex:0 0 auto;">
            <input type="checkbox" id="alertEnable"> 通知オン
          </label>
          <label class="row" style="gap:6px; flex:0 0 auto;">
            閾値M
            <input id="alertMinMag" type="number" step="0.1" min="0" max="10" value="5.0" style="width:72px;">
          </label>
        </div>
      </div>
      <div class="box">
        <h3>フィルタ</h3>
        <div class="row">
          <label>マグニチュード: <span id="magVal">2.5+</span></label>
        </div>
        <input id="magMin" type="range" min="2.5" max="7.5" step="0.1" value="2.5" style="width:100%;">
        <div class="row">
          <label class="row" style="gap:6px;">
            <input type="checkbox" id="fShallow" checked> 浅発
          </label>
          <label class="row" style="gap:6px;">
            <input type="checkbox" id="fInter" checked> 中深発
          </label>
          <label class="row" style="gap:6px;">
            <input type="checkbox" id="fDeep" checked> 深発
          </label>
        </div>
        <div class="row" style="margin-top:6px;">
          <label class="row" style="gap:6px;">
            <input type="checkbox" id="fHeat"> ヒートマップ表示
          </label>
        </div>
        <!-- 追加: 日付レンジ + 操作用ボタン -->
        <div class="row" style="gap:10px; margin-top:8px;">
          <label>開始日
            <input id="dateFrom" type="date" disabled>
          </label>
          <label>終了日
            <input id="dateTo" type="date" disabled>
          </label>
        </div>
      </div>
      <div class="box" id="customBox">
        <h3>カスタムマーカー</h3>
        <div class="row" style="margin-bottom:8px;">
          <button id="mkCreate" class="btn" title="クリック後、地図上をクリックでマーカー作成">作成モード</button>
          <button id="mkSave" class="btn primary" disabled>保存</button>
          <button id="mkDelete" class="btn danger" disabled>削除</button>
        </div>
        <label style="display:block;margin-bottom:6px;">
          タイトル
          <input id="mkTitle" type="text" placeholder="例: 観測ポイントA" disabled>
        </label>
        <label style="display:block;margin-bottom:6px;">
          メモ
          <textarea id="mkNote" placeholder="任意の説明" disabled></textarea>
        </label>
        <label style="display:block;margin-bottom:8px;">
          色
          <select id="mkColor" disabled>
            <option value="#2b7bff">青</option>
            <option value="#ff4d4f">赤</option>
            <option value="#00b894">緑</option>
            <option value="#f39c12">オレンジ</option>
            <option value="#7a5cff">紫</option>
          </select>
        </label>
        <div class="small muted" id="mkHint">「作成モード」を押し → 地図クリックで新規。マーカーはドラッグで位置変更できます。</div>
        <div class="small muted" style="margin-top:8px;">マーカー一覧</div>
        <ul id="mkList" class="list" style="max-height:180px;"></ul>
      </div>
      <!-- Country images box -->
      <div class="box" id="countryBox">
        <h3>国のイメージ</h3>
        <div id="countryInfo" class="small muted">地図をクリックすると、その国の画像が表示されます。</div>
        <div id="countryGallery" class="gallery"></div>
      </div>
      <div class="box">
        <h3>ヒット一覧 <span id="hitCount" class="small muted"></span></h3>
        <ul id="list" class="list"></ul>
      </div>
      <div class="small muted">操作: クリックでポップアップ、ダブルクリックでズーム / リスト選択で該当地点へ移動</div>
    </aside>
    <section class="map"><div id="map"></div></section>
  </div>

  <!-- Alert stack overlay -->
  <div id="alertStack" class="alerts" aria-live="polite" aria-atomic="false"></div>

  

  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/leaflet.markercluster.js"></script>
  <!-- Leaflet.heat plugin -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script>
    // Opening splash control
    (function(){
      const splash = document.getElementById('siteSplash');
      function hideSplash(){
        if (!splash || splash.classList.contains('is-hidden')) return;
        splash.classList.add('is-hidden');
        // remove from DOM after transition ends to free events
        setTimeout(() => splash && splash.remove && splash.remove(), 800);
      }
      // If data load finishes earlier, we will also hide it in loadData() end, but ensure fallback here
      window.addEventListener('load', () => {
        // Allow a tiny delay so first map paint is ready behind the fade
        setTimeout(hideSplash, 250);
      });
      // Safety fallback after 6s (in case load event is blocked)
      setTimeout(hideSplash, 6000);
      // expose for optional manual control
      window.__hideSplash = hideSplash;
    })();
    const state = {
      data: [],
      markers: [],
      cluster: null,
      map: null,
      query: '',
      magMin: 2.5,
      allow: { shallow: true, intermediate: true, deep: true },
      dataSource: 'usgs_month',
      // 追加: 時間レンジと最後のフィルタ結果
      timeFrom: null,   // ms
      timeTo: null,     // ms
      lastFiltered: [],
      custom: {
        creation: false,
        selectedId: null,
        items: [], // {id, lat, lon, title, note, color}
        layer: null
      },
      // 追加: ヒートマップ用状態
      heat: { layer: null, enabled: false }
      ,
      // リアルタイム更新
      realtime: { enabled: false, timer: null, intervalMs: 60000, lastUpdated: null },
      // アラート
      alert: { enabled: false, minMag: 5.0, seen: new Set(), initialized: false },
      audioCtx: null
    };

    const colors = { shallow: '#2b7bff', intermediate: '#ff9f1a', deep: '#7a5cff' };

    function depthTag(cat){
      const jp = cat==='shallow'?'浅発':cat==='intermediate'?'中深発':'深発';
      return `<span class="tag ${cat}">${jp}</span>`;
    }

    function formatJST(iso){
      try {
        const d = new Date(iso);
        return d.toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo', year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      } catch(e) { return iso; }
    }

    function createPopup(e){
      return `<b>${e.place || '(場所情報なし)'}</b><br>`+
             `マグニチュード M ${e.mag.toFixed(1)} / 深さ ${Math.round(e.depth)} km ${depthTag(e.depthCategory)}<br>`+
             `発生時刻 (JST): ${formatJST(e.time)}`;
    }

    function applyFilters(row){
      if (row.mag < state.magMin) return false;
      if (!state.allow[row.depthCategory]) return false;
      // 追加: 日付フィルタ
      const t = new Date(row.time).getTime();
      if (state.timeFrom != null && t < state.timeFrom) return false;
      if (state.timeTo != null && t > state.timeTo) return false;
      if (state.query){
        const q = state.query.toLowerCase();
        const place = (row.place||'').toLowerCase();
        if (!place.includes(q)) return false;
      }
      return true;
    }

    function updateMarkers(){
      // clear cluster
      if (state.cluster){ state.cluster.clearLayers(); }
      state.markers = [];

      const filtered = state.data.filter(applyFilters);
      state.lastFiltered = filtered; // 追加: 保持

      for (const e of filtered){
        const m = L.circleMarker([e.lat, e.lon], {
          radius: 3 + e.mag,
          color: colors[e.depthCategory] || '#666',
          weight: 2,
          fill: true,
          fillOpacity: 0.7,
          fillColor: colors[e.depthCategory] || '#666'
        }).bindPopup(createPopup(e));
        m.on('dblclick', () => state.map.setView([e.lat, e.lon], Math.max(7, state.map.getZoom()+1)));
        state.cluster.addLayer(m);
        state.markers.push({ id: e.id, marker: m, data: e });
      }

      // 追加: ヒートマップ更新（Mに応じて重み付け）
      if (state.heat && state.heat.layer){
        const points = filtered.map(e => {
          const mag = Number.isFinite(e.mag) ? e.mag : 2.5;
          const w = Math.max(0.1, Math.min(1, (mag - 2.5) / 5));
          return [e.lat, e.lon, w];
        });
        state.heat.layer.setLatLngs(points);
        if (state.heat.enabled) {
          if (!state.map.hasLayer(state.heat.layer)) state.map.addLayer(state.heat.layer);
        } else {
          if (state.map.hasLayer(state.heat.layer)) state.map.removeLayer(state.heat.layer);
        }
      }
      document.getElementById('hitCount').textContent = `(${filtered.length} 件)`;
      renderList(filtered.slice(0, 500)); // パネル描画は最大500件に抑制
    }

    function renderList(rows){
      const ul = document.getElementById('list');
      ul.innerHTML = '';
      const frag = document.createDocumentFragment();
      for (const e of rows){
        const li = document.createElement('li');
  li.className = 'item';
  li.innerHTML = `${formatJST(e.time)} / M ${e.mag.toFixed(1)} ${depthTag(e.depthCategory)}<br><span class="small">${e.place||'(場所情報なし)'}</span>`;
        li.onclick = () => {
          const rec = state.markers.find(x => x.data.id === e.id);
          if (rec){
            rec.marker.openPopup();
            state.map.setView([e.lat, e.lon], Math.max(6, state.map.getZoom()));
          }
        };
        frag.appendChild(li);
      }
      ul.appendChild(frag);
    }

    function initMap(){
      // 世界全体を見渡せる初期表示
      state.map = L.map('map', { center: [20, 0], zoom: 2, worldCopyJump: true });
      const basePositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '地図データ: &copy; OpenStreetMap貢献者 / タイル: &copy; CARTO',
        maxZoom: 19, subdomains: 'abcd'
      });
      const baseGSI = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
        attribution: '地図: 地理院タイル 標準',
        maxZoom: 18
      });
      const baseGsiPale = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png', {
        attribution: '地図: 地理院タイル 淡色',
        maxZoom: 18
      });
      basePositron.addTo(state.map);
      state.cluster = L.markerClusterGroup({ disableClusteringAtZoom: 9 });
      state.map.addLayer(state.cluster);
      state.custom.layer = L.layerGroup().addTo(state.map);
      L.control.layers({ 'CARTO ライト': basePositron, '地理院 標準': baseGSI, '地理院 淡色': baseGsiPale }, null, { collapsed: true }).addTo(state.map);
      L.control.scale({ imperial: false }).addTo(state.map);

      // 追加: 凡例
      addLegendControl();

      // 追加: ヒートレイヤー作成（まだ地図に追加しない）
      state.heat.layer = L.heatLayer([], {
        radius: 22,
        blur: 16,
        maxZoom: 11,
        minOpacity: 0.3,
        gradient: { 0.2: '#2b7bff', 0.5: '#ff9f1a', 0.9: '#7a5cff' }
      });
    }

    // 追加: 凡例コントロール
    function addLegendControl(){
      const Legend = L.Control.extend({
        options: { position: 'bottomright' },
        onAdd: function(map){
          const div = L.DomUtil.create('div', 'leaflet-control');
          div.style.background = 'var(--legend-bg, #fff)';
          div.style.padding = '8px 10px';
          div.style.border = '1px solid #ccc';
          div.style.borderRadius = '8px';
          div.style.boxShadow = '0 1px 2px rgba(0,0,0,.08)';
          div.style.fontSize = '12px';
          div.innerHTML = `
            <div style="font-weight:600; margin-bottom:4px;">凡例</div>
            <div style="display:flex; gap:10px; align-items:center;">
              <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${colors.shallow};border:1px solid #999;"></span>浅発
              <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${colors.intermediate};border:1px solid #999;"></span>中深発
              <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${colors.deep};border:1px solid #999;"></span>深発
            </div>
            <div class="small" style="margin-top:4px; opacity:.7;">円サイズはMに比例</div>
          `;
          return div;
        }
      });
      state.map.addControl(new Legend());
    }

    // Country detection and image search helpers
    async function fetchCountryByLatLng(lat, lon){
      try{
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=3&accept-language=en`;
        const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
        const js = await res.json();
        const country = (js && js.address && (js.address.country)) || js.name || js.display_name || '';
        const code = (js && js.address && js.address.country_code) ? String(js.address.country_code).toUpperCase() : '';
        return { country, code };
      } catch(e){ console.error('reverse geocode error', e); return { country: '', code: '' }; }
    }

    async function fetchCountryImages(countryName, limit=9){
      try {
        // 1) find the country page on English Wikipedia
        const s1 = await fetch(`https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(countryName)}&srlimit=1&format=json&origin=*`);
        const j1 = await s1.json();
        const pageId = j1 && j1.query && j1.query.search && j1.query.search[0] && j1.query.search[0].pageid;
        if (!pageId) return [];
        // 2) list images used on that page
        const s2 = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=images&pageids=${pageId}&imlimit=50&format=json&origin=*`);
        const j2 = await s2.json();
        const imgs = (j2 && j2.query && j2.query.pages && j2.query.pages[pageId] && j2.query.pages[pageId].images) || [];
        const fileTitles = imgs.map(it => it.title).filter(t => /(\.jpg|\.jpeg|\.png)$/i.test(t)).slice(0, 24);
        if (!fileTitles.length) return [];
        // 3) fetch URLs for these files
        const titlesParam = encodeURIComponent(fileTitles.join('|'));
        const s3 = await fetch(`https://en.wikipedia.org/w/api.php?action=query&titles=${titlesParam}&prop=imageinfo&iiprop=url&iiurlwidth=400&format=json&origin=*`);
        const j3 = await s3.json();
        const pages = (j3 && j3.query && j3.query.pages) || {};
        const urls = Object.values(pages)
          .map(p => p.imageinfo && p.imageinfo[0] && (p.imageinfo[0].thumburl || p.imageinfo[0].url))
          .filter(Boolean)
          .slice(0, limit);
        return urls;
      } catch(e){ console.error('wiki image fetch error', e); return []; }
    }

    function renderCountryGallery(countryName, images){
      const info = document.getElementById('countryInfo');
      const gal = document.getElementById('countryGallery');
      if (!info || !gal) return;
      if (!countryName){
        info.textContent = '国が特定できませんでした。';
        gal.innerHTML = '';
        return;
      }
      info.textContent = `${countryName} のイメージ`;
      gal.innerHTML = '';
      const frag = document.createDocumentFragment();
      for (const url of images){
        const wrap = document.createElement('div');
        wrap.className = 'thumb';
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.src = url;
        img.alt = countryName;
        wrap.appendChild(img);
        frag.appendChild(wrap);
      }
      gal.appendChild(frag);
      if (!images.length){
        gal.innerHTML = '<div class="small muted">画像が見つかりませんでした。</div>';
      }
    }

    async function fetchCountryFlow(lat, lon){
      const info = document.getElementById('countryInfo');
      const gal = document.getElementById('countryGallery');
      if (info) info.textContent = '国を特定しています…';
      if (gal) gal.innerHTML = '';
      const { country } = await fetchCountryByLatLng(lat, lon);
      if (!country){ renderCountryGallery(null, []); return; }
      if (info) info.textContent = `${country} のイメージを取得中…`;
      const images = await fetchCountryImages(country, 9);
      renderCountryGallery(country, images);
    }

    // ---- Earthquake alerting ----
    function ensureAudio(){
      if (!state.audioCtx){
        try{ state.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(e){ state.audioCtx = null; }
      }
      return state.audioCtx;
    }

    function playAlertSound(mag){
      const ctx = ensureAudio();
      if (!ctx) return;
      const beeps = mag >= 6 ? 3 : (mag >= 5 ? 2 : 1);
      const startAt = ctx.currentTime;
      for (let i=0;i<beeps;i++){
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = Math.min(1200, 400 + (mag*120));
        g.gain.setValueAtTime(0, startAt + i*0.35);
        g.gain.linearRampToValueAtTime(0.25, startAt + i*0.35 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.001, startAt + i*0.35 + 0.28);
        o.connect(g).connect(ctx.destination);
        o.start(startAt + i*0.35);
        o.stop(startAt + i*0.35 + 0.3);
      }
    }

    function triggerAlert(e){
      if (!state.alert.enabled) return;
      const stack = document.getElementById('alertStack');
      if (!stack) return;
      const div = document.createElement('div');
      const strong = e.mag>=6 ? 'strong' : e.mag>=5 ? 'medium' : 'light';
      div.className = `alert-card ${strong} alert-enter`;
      div.innerHTML = `
        <div class="alert-badge">M ${e.mag.toFixed(1)}</div>
        <div class="alert-body">
          <div class="alert-title">${e.place || '(場所情報なし)'}</div>
          <div class="alert-meta small">深さ ${Math.round(e.depth)} km / ${formatJST(e.time)}</div>
        </div>
        <button class="alert-action" title="この地点へ">移動</button>
      `;
      // actions
      const action = div.querySelector('.alert-action');
      if (action){
        action.addEventListener('click', () => {
          try { state.map.setView([e.lat, e.lon], Math.max(6, state.map.getZoom())); } catch(_){}
        });
      }
      // remove after 12s
      const ttl = setTimeout(() => div.remove(), 12000);
      div.addEventListener('click', () => { clearTimeout(ttl); div.remove(); });
      stack.prepend(div);
      try { playAlertSound(e.mag); } catch(_){}
    }

    function handleAlerts(rows){
      if (!state.alert.enabled) return;
      if (!state.alert.initialized) return;
      const now = Date.now();
      const recentMs = 10 * 60 * 1000; // last 10 minutes
      const minMag = state.alert.minMag || 0;
      const seen = state.alert.seen || new Set();
      const newcomers = [];
      for (const e of rows){
        if (!seen.has(e.id)){
          const t = new Date(e.time).getTime();
          if ((!Number.isFinite(t) || now - t <= recentMs) && (e.mag||0) >= minMag){
            newcomers.push(e);
          }
          seen.add(e.id);
        }
      }
      // Trim seen to prevent growth
      if (seen.size > 10000){
        const keep = Array.from(seen).slice(-5000);
        state.alert.seen = new Set(keep);
      } else {
        state.alert.seen = seen;
      }
      newcomers.sort((a,b)=> (new Date(a.time)) - (new Date(b.time)));
      for (const e of newcomers){ triggerAlert(e); }
    }

    function depthCategoryOf(depthKm){
      if (!Number.isFinite(depthKm)) return 'shallow';
      if (depthKm < 70) return 'shallow';
      if (depthKm < 300) return 'intermediate';
      return 'deep';
    }

    function normalizeLocal(rows){
      return (rows||[]).map((r,i) => {
        const id = r.id ?? `${r.time||''}_${r.lat}_${r.lon}_${i}`;
        const depth = Number(r.depth);
        const cat = r.depthCategory || depthCategoryOf(depth);
        return { id, lat: Number(r.lat), lon: Number(r.lon), mag: Number(r.mag)||0, depth, place: r.place||'', time: r.time, depthCategory: cat };
      }).filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));
    }

    function normalizeUSGS(geojson){
      const feats = (geojson && geojson.features) ? geojson.features : [];
      return feats.map((f,i) => {
        const c = (f.geometry && f.geometry.coordinates) || [null,null,null];
        const lon = Number(c[0]);
        const lat = Number(c[1]);
        const depth = Number(c[2]);
        const mag = Number(f.properties && f.properties.mag);
        const place = f.properties && f.properties.place || '';
        const time = f.properties && f.properties.time ? new Date(f.properties.time).toISOString() : '';
        const id = f.id || (f.properties && f.properties.code) || `${time}_${lat}_${lon}_${i}`;
        return { id, lat, lon, mag: mag||0, depth: depth||0, place, time, depthCategory: depthCategoryOf(depth) };
      }).filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));
    }

    async function loadData(){
      let rows = [];
      let sourceText = '';
      try {
        if (state.dataSource === 'local'){
          const res = await fetch('earthquakes_events.json');
          const raw = await res.json();
          rows = normalizeLocal(raw);
          sourceText = 'ローカル（日本・過去3年）';
        } else {
          // USGS GeoJSON feed
          const urlMap = {
            usgs_hour: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson',
            usgs_day: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson',
            usgs_week: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson',
            usgs_month: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson'
          };
          const url = urlMap[state.dataSource] || urlMap.usgs_month;
          const res = await fetch(url);
          const gj = await res.json();
          rows = normalizeUSGS(gj);
          sourceText = state.dataSource==='usgs_hour'?'USGS（過去1時間・世界）'
                      : state.dataSource==='usgs_day'?'USGS（過去24時間・世界）'
                      : state.dataSource==='usgs_week'?'USGS（過去7日・世界）'
                      : 'USGS（過去30日・世界）';
        }
      } catch (e){
        console.error('データ取得エラー', e);
      }

      state.data = rows;
      // 初回は既存データを既読として登録してスパム抑制
      if (!state.alert.initialized){
        try { state.alert.seen = new Set(rows.map(r => r.id)); } catch(_) { state.alert.seen = new Set(); }
        state.alert.initialized = true;
      }

      // 追加: データから日付レンジ初期化
      const times = state.data.map(r => new Date(r.time).getTime()).filter(Number.isFinite);
      if (times.length) {
        const minT = Math.min(...times);
        const maxT = Math.max(...times);
        const inFrom = document.getElementById('dateFrom');
        const inTo = document.getElementById('dateTo');

        const toLocalYMD = (ms) => {
          const d = new Date(ms);
          const tz = d.getTimezoneOffset() * 60000;
          const local = new Date(ms - tz);
          return local.toISOString().slice(0,10);
        };
        inFrom.min = toLocalYMD(minT);
        inFrom.max = toLocalYMD(maxT);
        inTo.min = toLocalYMD(minT);
        inTo.max = toLocalYMD(maxT);

        // 既定は全期間
        inFrom.value = toLocalYMD(minT);
        inTo.value = toLocalYMD(maxT);
        state.timeFrom = new Date(inFrom.value).getTime();
        // 終日の末端 23:59:59.999
        state.timeTo = new Date(new Date(inTo.value).setHours(23,59,59,999)).getTime();

        inFrom.disabled = false;
        inTo.disabled = false;
      }

      const info = document.getElementById('sourceInfo');
      if (info) info.textContent = `データ: ${sourceText || '不明'}`;

  updateMarkers();
  // アラート判定（初回はスキップ済み）
  handleAlerts(rows);
      // Hide splash when initial data is ready
      if (window.__hideSplash) window.__hideSplash();
    }

    function wireUI(){
      const q = document.getElementById('q');
      const mag = document.getElementById('magMin');
      const magVal = document.getElementById('magVal');
      const fSh = document.getElementById('fShallow');
      const fIm = document.getElementById('fInter');
      const fDp = document.getElementById('fDeep');
  const fHeat = document.getElementById('fHeat');
  const selSource = document.getElementById('dataSource');
  const rtEnable = document.getElementById('rtEnable');
  const rtEvery = document.getElementById('rtEvery');
  const rtStatus = document.getElementById('rtStatus');
  const alertEnable = document.getElementById('alertEnable');
  const alertMinMag = document.getElementById('alertMinMag');

      q.addEventListener('input', () => { state.query = q.value.trim(); updateMarkers(); });
      mag.addEventListener('input', () => { state.magMin = parseFloat(mag.value); magVal.textContent = `${state.magMin.toFixed(1)}+`; updateMarkers(); });
      fSh.addEventListener('change', () => { state.allow.shallow = fSh.checked; updateMarkers(); });
      fIm.addEventListener('change', () => { state.allow.intermediate = fIm.checked; updateMarkers(); });
      fDp.addEventListener('change', () => { state.allow.deep = fDp.checked; updateMarkers(); });
  // 追加: ヒートマップ切替
  fHeat.addEventListener('change', () => { state.heat.enabled = fHeat.checked; updateMarkers(); });

      // データソース変更
      if (selSource){
        selSource.value = state.dataSource;
        selSource.addEventListener('change', () => {
          state.dataSource = selSource.value;
          // データソース切替時は見たIDをリセットし初回スパム抑制
          state.alert.initialized = false;
          loadData();
          // ローカル選択時はリアルタイム無効化
          if (state.dataSource === 'local' && state.realtime.enabled){
            stopRealtime();
            if (rtEnable) rtEnable.checked = false;
            if (rtStatus) rtStatus.textContent = 'ローカルデータでは自動更新は無効です。';
          }
        });
      }

  // 追加: 日付レンジ
      const inFrom = document.getElementById('dateFrom');
      const inTo = document.getElementById('dateTo');

      const updateDateRange = () => {
        if (inFrom.value) state.timeFrom = new Date(inFrom.value).getTime(); else state.timeFrom = null;
        if (inTo.value) {
          const end = new Date(inTo.value);
          state.timeTo = new Date(end.setHours(23,59,59,999)).getTime();
        } else {
          state.timeTo = null;
        }
        updateMarkers();
      };
      inFrom.addEventListener('change', updateDateRange);
      inTo.addEventListener('change', updateDateRange);

      // ---- Realtime wiring ----
      function setRtStatus(){
        if (!rtStatus) return;
        if (!state.realtime.enabled){ rtStatus.textContent = ''; return; }
        const t = state.realtime.lastUpdated ? new Date(state.realtime.lastUpdated) : null;
        const hms = t ? t.toLocaleTimeString('ja-JP', { hour12:false }) : '—';
        rtStatus.textContent = `リアルタイム更新: ON / 最終更新 ${hms}`;
      }

      async function refreshRealtime(){
        // Skip if disabled or local
        if (!state.realtime.enabled || state.dataSource === 'local') return;
        try{
          const urlMap = {
            usgs_hour: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson',
            usgs_day: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson',
            usgs_week: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson',
            usgs_month: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson'
          };
          const url = urlMap[state.dataSource] || urlMap.usgs_hour;
          const res = await fetch(url, { cache: 'no-cache' });
          const gj = await res.json();
          const rows = normalizeUSGS(gj);
          // Keep existing date range filter selections; just replace data and rerender
          state.data = rows;
          state.realtime.lastUpdated = Date.now();
          updateMarkers();
          // New alerts
          handleAlerts(rows);
          setRtStatus();
        } catch(e){
          console.error('リアルタイム取得エラー', e);
          if (rtStatus) rtStatus.textContent = 'リアルタイム取得エラー。接続を確認。';
        }
      }

      function startRealtime(){
        stopRealtime();
        state.realtime.enabled = true;
        setRtStatus();
        // Immediate refresh, then interval
        refreshRealtime();
        state.realtime.timer = setInterval(refreshRealtime, state.realtime.intervalMs);
      }
      function stopRealtime(){
        if (state.realtime.timer){ clearInterval(state.realtime.timer); state.realtime.timer = null; }
        state.realtime.enabled = false;
        setRtStatus();
      }
      if (rtEvery){
        rtEvery.value = String(state.realtime.intervalMs);
        rtEvery.addEventListener('change', () => {
          state.realtime.intervalMs = parseInt(rtEvery.value||'60000', 10) || 60000;
          if (state.realtime.enabled){ startRealtime(); }
        });
      }
      if (rtEnable){
        rtEnable.checked = state.realtime.enabled;
        rtEnable.addEventListener('change', () => {
          if (rtEnable.checked){
            if (state.dataSource === 'local'){
              rtEnable.checked = false;
              if (rtStatus) rtStatus.textContent = 'ローカルデータでは自動更新は無効です。';
              return;
            }
            startRealtime();
          } else {
            stopRealtime();
          }
        });
      }

      // ---- Alert wiring ----
      if (alertEnable){
        alertEnable.checked = state.alert.enabled;
        alertEnable.addEventListener('change', () => { state.alert.enabled = alertEnable.checked; });
      }
      if (alertMinMag){
        alertMinMag.value = String(state.alert.minMag.toFixed(1));
        alertMinMag.addEventListener('change', () => {
          const v = parseFloat(alertMinMag.value);
          if (!Number.isFinite(v)) return;
          state.alert.minMag = Math.max(0, Math.min(10, v));
        });
      }

      // ヒットにズーム/現在地ボタンは削除
      // ---- Custom marker UI ----
      const btnCreate = document.getElementById('mkCreate');
      const btnSave = document.getElementById('mkSave');
      const btnDelete = document.getElementById('mkDelete');
      const inTitle = document.getElementById('mkTitle');
      const inNote = document.getElementById('mkNote');
      const inColor = document.getElementById('mkColor');
      const listBox = document.getElementById('mkList');

      btnCreate.addEventListener('click', () => {
        state.custom.creation = !state.custom.creation;
        btnCreate.textContent = state.custom.creation ? '作成中…(終了)' : '作成モード';
        btnCreate.classList.toggle('primary', state.custom.creation);
      });

      btnSave.addEventListener('click', () => {
        if (state.custom.selectedId == null) return;
        const it = state.custom.items.find(x => x.id === state.custom.selectedId);
        if (!it) return;
        it.title = inTitle.value.trim();
        it.note = inNote.value.trim();
        it.color = inColor.value;
        saveCustom();
        redrawCustom();
      });

      btnDelete.addEventListener('click', () => {
        if (state.custom.selectedId == null) return;
        const idx = state.custom.items.findIndex(x => x.id === state.custom.selectedId);
        if (idx >= 0) state.custom.items.splice(idx,1);
        state.custom.selectedId = null;
        bindForm(null);
        saveCustom();
        redrawCustom();
      });

      function bindForm(item){
        const disabled = !item;
        inTitle.disabled = inNote.disabled = inColor.disabled = btnSave.disabled = btnDelete.disabled = disabled;
        if (!item){
          inTitle.value=''; inNote.value=''; inColor.value='#2b7bff';
        } else {
          inTitle.value = item.title || '';
            inNote.value = item.note || '';
            inColor.value = item.color || '#2b7bff';
        }
      }

      function customIcon(color){
        return L.divIcon({ html: `<div class=\"cm-dot\" style=\"background:${color}\"></div>`, className:'cm', iconSize:[16,16], iconAnchor:[8,8] });
      }

      function redrawCustom(){
        state.custom.layer.clearLayers();
        listBox.innerHTML='';
        const frag = document.createDocumentFragment();
        for (const it of state.custom.items){
          const mk = L.marker([it.lat, it.lon], { draggable:true, icon: customIcon(it.color||'#2b7bff') })
            .addTo(state.custom.layer)
            .bindPopup(`<b>${(it.title||'カスタム')}</b><br>${(it.note||'')}<br><span class=small>${it.lat.toFixed(4)}, ${it.lon.toFixed(4)}</span>`);
          mk.on('click', () => { state.custom.selectedId = it.id; bindForm(it); highlightList(); });
          mk.on('dragend', ev => { const p = ev.target.getLatLng(); it.lat = p.lat; it.lon = p.lng; saveCustom(); redrawCustom(); });
          const li = document.createElement('li');
          li.className='item';
          li.dataset.id = it.id;
          li.innerHTML = `<span style=\"display:inline-block;width:10px;height:10px;border-radius:50%;background:${it.color||'#2b7bff'};margin-right:6px;\"></span>${(it.title||'カスタムポイント')}<br><span class=small>${it.lat.toFixed(3)}, ${it.lon.toFixed(3)}</span>`;
          li.onclick = () => { state.custom.selectedId = it.id; bindForm(it); highlightList(); state.map.setView([it.lat,it.lon], Math.max(6,state.map.getZoom())); };
          frag.appendChild(li);
        }
        listBox.appendChild(frag);
        highlightList();
      }

      function highlightList(){
        [...listBox.children].forEach(li => li.classList.toggle('active', String(li.dataset.id)===String(state.custom.selectedId)) );
      }

      function saveCustom(){
        try { localStorage.setItem('customMarkers', JSON.stringify(state.custom.items)); } catch(e) {}
      }
      function loadCustom(){
        try { const raw = localStorage.getItem('customMarkers'); if (raw) state.custom.items = JSON.parse(raw)||[]; } catch(e) { state.custom.items=[]; }
      }

      // map click: create custom marker if in creation mode; otherwise fetch country images
      state.map.on('click', e => {
        if (state.custom.creation){
          const id = Date.now();
          const item = { id, lat:e.latlng.lat, lon:e.latlng.lng, title:'新しいポイント', note:'', color:'#2b7bff' };
          state.custom.items.push(item);
          state.custom.creation = false;
          btnCreate.textContent='作成モード';
          btnCreate.classList.remove('primary');
          state.custom.selectedId = id;
          saveCustom();
          bindForm(item);
          redrawCustom();
          return;
        }
        // Ignore clicks on interactive layers (markers, clusters)
        const tgt = e.originalEvent && e.originalEvent.target;
        if (tgt && (tgt.closest && (tgt.closest('.leaflet-interactive') || tgt.closest('.marker-cluster')))) return;
        // Fetch country images for clicked location
        fetchCountryFlow(e.latlng.lat, e.latlng.lng);
      });

      loadCustom();
      redrawCustom();
      bindForm(null);
      // panel toggle (inside panel with icon)
      const layout = document.querySelector('.layout');
      const toggleInside = document.getElementById('togglePanelInside');
      const leftIcon = '<svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>';
      const rightIcon = '<svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8.59 16.59 10 18l6-6-6-6-1.41 1.41L13.17 12z"></path></svg>';
      function setToggleIcon(){
        const collapsed = layout.classList.contains('collapsed');
        toggleInside.innerHTML = collapsed ? rightIcon : leftIcon;
        toggleInside.title = collapsed ? 'パネル展開' : 'パネル縮小';
        toggleInside.setAttribute('aria-label', collapsed ? 'パネル展開' : 'パネル縮小');
      }
      setToggleIcon();
      toggleInside.addEventListener('click', () => {
        layout.classList.toggle('collapsed');
        setToggleIcon();
        setTimeout(() => { if (state.map) state.map.invalidateSize(); }, 200);
      });

      // （チャットボット機能は削除済み）
    }

    // ヒットにズーム機能は削除

    // boot
    initMap();
    wireUI();
    loadData();
  </script>
</body>
</html>
